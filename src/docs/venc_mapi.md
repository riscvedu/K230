{"payload":{"allShortcutsEnabled":false,"fileTree":{"docs":{"items":[{"name":"venc_mapi.md","path":"docs/venc_mapi.md","contentType":"file"}],"totalCount":1},"":{"items":[{"name":"docs","path":"docs","contentType":"directory"},{"name":"hello_world","path":"hello_world","contentType":"directory"},{"name":"README.md","path":"README.md","contentType":"file"},{"name":"从零开始玩转K230.pdf","path":"从零开始玩转K230.pdf","contentType":"file"}],"totalCount":4}},"fileTreeProcessingTime":9.575932,"foldersToFetch":[],"reducedMotionEnabled":null,"repo":{"id":738409990,"defaultBranch":"main","name":"K230","ownerLogin":"riscvedu","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2024-01-03T06:54:25.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/102638817?v=4","public":true,"private":false,"isOrgOwned":true},"symbolsExpanded":false,"treeExpanded":true,"refInfo":{"name":"52c070d6b8463406f0922a7a24b102ef67dc839e","listCacheKey":"v0:1704773837.0","canEdit":false,"refType":"tree","currentOid":"52c070d6b8463406f0922a7a24b102ef67dc839e"},"path":"docs/venc_mapi.md","currentUser":null,"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/riscvedu/K230/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":null,"repoAlertsPath":"/riscvedu/K230/security/dependabot","repoSecurityAndAnalysisPath":"/riscvedu/K230/settings/security_analysis","repoOwnerIsOrg":true,"currentUserCanAdminRepo":false},"displayName":"venc_mapi.md","displayUrl":"https://github.com/riscvedu/K230/blob/52c070d6b8463406f0922a7a24b102ef67dc839e/docs/venc_mapi.md?raw=true","headerInfo":{"blobSize":"37.1 KB","deleteInfo":{"deleteTooltip":"You must be signed in to make or propose changes"},"editInfo":{"editTooltip":"You must be signed in to make or propose changes"},"ghDesktopPath":null,"gitLfsPath":null,"onBranch":false,"shortPath":"b08bd53","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Friscvedu%2FK230%2Fblob%2F52c070d6b8463406f0922a7a24b102ef67dc839e%2Fdocs%2Fvenc_mapi.md","isCSV":false,"isRichtext":true,"toc":[{"level":1,"text":"K230 VENC MAPI介绍","anchor":"k230-venc-mapi介绍","htmlText":"K230 VENC MAPI介绍"},{"level":2,"text":"1. 概述","anchor":"1-概述","htmlText":"1. 概述"},{"level":2,"text":"2. 编码数据流图","anchor":"2-编码数据流图","htmlText":"2. 编码数据流图"},{"level":2,"text":"3. API接口","anchor":"3-api接口","htmlText":"3. API接口"},{"level":3,"text":"3.1 kd_mapi_venc_init","anchor":"31-kd_mapi_venc_init","htmlText":"3.1 kd_mapi_venc_init"},{"level":4,"text":"3.1.1 k_venc_chn_attr","anchor":"311-k_venc_chn_attr","htmlText":"3.1.1 k_venc_chn_attr"},{"level":4,"text":"3.1.2 k_venc_attr","anchor":"312-k_venc_attr","htmlText":"3.1.2 k_venc_attr"},{"level":4,"text":"3.1.3 k_venc_rc_attr","anchor":"313-k_venc_rc_attr","htmlText":"3.1.3 k_venc_rc_attr"},{"level":4,"text":"3.1.4 k_venc_cbr","anchor":"314-k_venc_cbr","htmlText":"3.1.4 k_venc_cbr"},{"level":4,"text":"3.1.5 k_venc_vbr","anchor":"315-k_venc_vbr","htmlText":"3.1.5 k_venc_vbr"},{"level":4,"text":"3.1.6 k_venc_fixqp","anchor":"316-k_venc_fixqp","htmlText":"3.1.6 k_venc_fixqp"},{"level":4,"text":"3.1.7 k_venc_mjpeg_fixqp","anchor":"317-k_venc_mjpeg_fixqp","htmlText":"3.1.7 k_venc_mjpeg_fixqp"},{"level":3,"text":"3.2 kd_mapi_venc_deinit","anchor":"32-kd_mapi_venc_deinit","htmlText":"3.2 kd_mapi_venc_deinit"},{"level":3,"text":"3.3 kd_mapi_venc_registercallback","anchor":"33-kd_mapi_venc_registercallback","htmlText":"3.3 kd_mapi_venc_registercallback"},{"level":4,"text":"3.3.1 kd_venc_callback_s","anchor":"331-kd_venc_callback_s","htmlText":"3.3.1 kd_venc_callback_s"},{"level":5,"text":"3.3.2 pfn_venc_dataproc","anchor":"332-pfn_venc_dataproc","htmlText":"3.3.2 pfn_venc_dataproc"},{"level":5,"text":"3.3.3 kd_venc_data_s","anchor":"333-kd_venc_data_s","htmlText":"3.3.3 kd_venc_data_s"},{"level":5,"text":"3.3.4 k_venc_data_pack_s","anchor":"334-k_venc_data_pack_s","htmlText":"3.3.4 k_venc_data_pack_s"},{"level":3,"text":"3.4 kd_mapi_venc_unregistercallback","anchor":"34-kd_mapi_venc_unregistercallback","htmlText":"3.4 kd_mapi_venc_unregistercallback"},{"level":3,"text":"3.5 kd_mapi_venc_start","anchor":"35-kd_mapi_venc_start","htmlText":"3.5 kd_mapi_venc_start"},{"level":3,"text":"3.6 kd_mapi_venc_stop","anchor":"36-kd_mapi_venc_stop","htmlText":"3.6 kd_mapi_venc_stop"},{"level":3,"text":"3.7 kd_mapi_venc_bind_vi","anchor":"37-kd_mapi_venc_bind_vi","htmlText":"3.7 kd_mapi_venc_bind_vi"},{"level":3,"text":"3.8 kd_mapi_venc_unbind_vi","anchor":"38-kd_mapi_venc_unbind_vi","htmlText":"3.8 kd_mapi_venc_unbind_vi"},{"level":3,"text":"3.9 kd_mapi_venc_request_idr","anchor":"39-kd_mapi_venc_request_idr","htmlText":"3.9 kd_mapi_venc_request_idr"},{"level":3,"text":"3.10 kd_mapi_venc_enable_idr","anchor":"310-kd_mapi_venc_enable_idr","htmlText":"3.10 kd_mapi_venc_enable_idr"},{"level":2,"text":"4. 错误码","anchor":"4-错误码","htmlText":"4. 错误码"},{"level":2,"text":"5. 调试信息","anchor":"5-调试信息","htmlText":"5. 调试信息"},{"level":2,"text":"6. sample","anchor":"6-sample","htmlText":"6. sample"}],"lineInfo":{"truncatedLoc":"1186","truncatedSloc":"858"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":false,"newDiscussionPath":"/riscvedu/K230/discussions/new","newIssuePath":"/riscvedu/K230/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/riscvedu/K230/blob/52c070d6b8463406f0922a7a24b102ef67dc839e/docs/venc_mapi.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/riscvedu/K230/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"rawBlobUrl":"https://github.com/riscvedu/K230/raw/52c070d6b8463406f0922a7a24b102ef67dc839e/docs/venc_mapi.md","renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><h1 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-k230-venc-mapi介绍\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#k230-venc-mapi介绍\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>K230 VENC MAPI介绍</h1>\n<h2 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-1-概述\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-概述\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>1. 概述</h2>\n<p dir=\"auto\">嘉楠发布的K230 AI芯片，提供了媒体处理软件平台MPP，可以支持应用软件的快速开发，通过MPP，应用开发者不需要关注芯片相关的底层处理，直接调用提供的MPI接口即可实现相应功能；但是由于MPI接口太多，调用流程也相对比较繁琐，为了简化用户的使用流程，对MPI接口和功能模块进行了抽象，形成了MAPI接口。对于VENC模块，目前MAPI接口主要在小核上调用，用以获取编码的码流数据。</p>\n<h2 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-2-编码数据流图\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-编码数据流图\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>2. 编码数据流图</h2>\n<p dir=\"auto\">图1</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/riscvedu/K230/blob/52c070d6b8463406f0922a7a24b102ef67dc839e/test_venc.png\"><img src=\"/riscvedu/K230/raw/52c070d6b8463406f0922a7a24b102ef67dc839e/test_venc.png\" alt=\"mapi encode channel\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">典型的编码流程包括了输入图像的接收、图像的编码、数据流的跨核传输以及码流的输出等过程。</p>\n<h2 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-3-api接口\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#3-api接口\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3. API接口</h2>\n<p dir=\"auto\">视频编码模块主要提供视频编码通道的创建和销毁、视频编码通道的开启和停止接收图像、设置和获取编码通道属性、注册和解注册获取码流的回调函数等功能。</p>\n<p dir=\"auto\">该功能模块提供以下MAPI：</p>\n<p dir=\"auto\"><a href=\"#4131-kd_mapi_venc_init\">kd_mapi_venc_init</a></p>\n<p dir=\"auto\"><a href=\"#4132-kd_mapi_venc_deinit\">kd_mapi_venc_deinit</a></p>\n<p dir=\"auto\"><a href=\"#4133-kd_mapi_venc_registercallback\">kd_mapi_venc_registercallback</a></p>\n<p dir=\"auto\"><a href=\"#4134-kd_mapi_venc_unregistercallback\">kd_mapi_venc_unregistercallback</a></p>\n<p dir=\"auto\"><a href=\"#4135-kd_mapi_venc_start\">kd_mapi_venc_start</a></p>\n<p dir=\"auto\"><a href=\"#4136-kd_mapi_venc_stop\">kd_mapi_venc_stop</a></p>\n<p dir=\"auto\"><a href=\"#4137-kd_mapi_venc_bind_vi\">kd_mapi_venc_bind_vi</a></p>\n<p dir=\"auto\"><a href=\"#4138-kd_mapi_venc_unbind_vi\">kd_mapi_venc_unbind_vi</a></p>\n<p dir=\"auto\"><a href=\"#4139-kd_mapi_venc_request_idr\">kd_mapi_venc_request_idr</a></p>\n<p dir=\"auto\"><a href=\"#41310-kd_mapi_venc_enable_idr\">kd_mapi_venc_enable_idr</a></p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-31-kd_mapi_venc_init\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#31-kd_mapi_venc_init\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1 kd_mapi_venc_init</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">初始化编码通道。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_init(k_u32 chn_num, <a href=\"#3115-k_venc_chn_attr\">k_venc_chn_attr</a> * pst_venc_attr)</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>pst_venc_attr</td>\n<td>VENC 通道属性指针</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为错误码</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无 。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<ul dir=\"auto\">\n<li>调用该接口前需要先初始化kd_mapi_sys_init ()和kd_mapi_media_init ()成功，详见“SYS MAPI”章节。</li>\n<li>重复初始化返回成功</li>\n</ul>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-311-k_venc_chn_attr\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#311-k_venc_chn_attr\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1.1 k_venc_chn_attr</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义编码通道属性结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct {\n <a href=\"#3116-k_venc_attr\">k_venc_attr</a> venc_attr;\n <a href=\"#3117-k_venc_rc_attr\">k_venc_rc_attr</a> rc_attr;\n} k_venc_chn_attr;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>venc_attr</td>\n<td>编码器属性。</td>\n</tr>\n<tr>\n<td>rc_attr</td>\n<td>码率控制器属性。</td>\n</tr>\n</tbody>\n</table>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-312-k_venc_attr\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#312-k_venc_attr\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1.2 k_venc_attr</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义编码器属性结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct {<br>\n k_payload_type type;<br>\n k_u32 stream_buf_size;<br>\n k_u32 stream_buf_cnt;<br>\n k_u32 pic_width;<br>\n k_u32 pic_height;<br>\n k_venc_profile profile;<br>\n} k_venc_attr;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td>编码协议类型枚。</td>\n</tr>\n<tr>\n<td>stream_buf_size</td>\n<td>码流buffer大小。</td>\n</tr>\n<tr>\n<td>stream_buf_cnt</td>\n<td>码流buffer个数。</td>\n</tr>\n<tr>\n<td>profile</td>\n<td>编码的等级枚举。</td>\n</tr>\n<tr>\n<td>pic_width</td>\n<td>编码图像宽度。 取值范围： <code>[MIN_WIDTH, MAX_WIDTH]</code>，以像素为单 位。 必须是MIN_ALIGN的整数倍。</td>\n</tr>\n<tr>\n<td>pic_height</td>\n<td>编码图像高度。 取值范围： <code>[MIN_HEIGHT, MAX_HEIGHT]</code>，以像素为 单位。 必须是MIN_ALIGN的整数倍。</td>\n</tr>\n</tbody>\n</table>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-313-k_venc_rc_attr\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#313-k_venc_rc_attr\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1.3 k_venc_rc_attr</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义编码通道码率控制器属性结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct {<br>\n <a href=\"#316-k_venc_rc_mode\">k_venc_rc_mode</a> rc_mode;<br>\n union {</p>\n<p dir=\"auto\">​\t\t<a href=\"#3118-k_venc_cbr\">k_venc_cbr</a> cbr;<br>\n  <a href=\"#3119-k_venc_vbr\">k_venc_vbr</a> vbr;<br>\n  <a href=\"#3120-k_venc_fixqp\">k_venc_fixqp</a> fixqp;<br>\n  <a href=\"#3121-k_venc_mjpeg_fixqp\">k_venc_mjpeg_fixqp</a> mjpeg_fixqp;<br>\n };<br>\n} k_venc_rc_attr;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rc_mode</td>\n<td>RC模式。</td>\n</tr>\n<tr>\n<td>cbr</td>\n<td>H.264/H.265协议编码通道固定比特率模式属性。</td>\n</tr>\n<tr>\n<td>Vbr</td>\n<td>H.264/H.265协议编码通道可变比特率模式属性。</td>\n</tr>\n<tr>\n<td>fixqp</td>\n<td>H.264/H.265协议编码通道固定qp模式属性。</td>\n</tr>\n<tr>\n<td>mjpeg_fixqp</td>\n<td>Mjpeg协议编码通道Fixqp模式属性。</td>\n</tr>\n</tbody>\n</table>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-314-k_venc_cbr\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#314-k_venc_cbr\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1.4 k_venc_cbr</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义H.264/H.265编码通道CBR属性结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct {<br>\n k_u32 gop;<br>\n k_u32 stats_time;<br>\n k_u32 src_frame_rate;<br>\n k_u32 dst_frame_rate;<br>\n k_u32 bit_rate;<br>\n} k_venc_cbr;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gop</td>\n<td>gop值。</td>\n</tr>\n<tr>\n<td>stats_time</td>\n<td>CBR码率统计时间，以秒为单位。 取值范围： <code>[1, 60]</code>。</td>\n</tr>\n<tr>\n<td>src_frame_rate</td>\n<td>输入帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>dst_frame_rate</td>\n<td>编码器输出帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>bit_rate</td>\n<td>平均bitrate，以kbps为单位。</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【注意事项】</p>\n<ul dir=\"auto\">\n<li>如果设置的码率超过芯片手册中规定的最大实时码率，则不能保证实时编码。</li>\n</ul>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-315-k_venc_vbr\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#315-k_venc_vbr\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1.5 k_venc_vbr</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义H.264/H.265编码通道VBR属性结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct {<br>\n k_u32 gop;<br>\n k_u32 stats_time;<br>\n k_u32 src_frame_rate;<br>\n k_u32 dst_frame_rate;<br>\n k_u32 max_bit_rate;<br>\n k_u32 bit_rate;<br>\n} k_venc_vbr;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gop</td>\n<td>gop值。</td>\n</tr>\n<tr>\n<td>stats_time</td>\n<td>VBR码率统计时间，以秒为单位。 取值范围： <code>[1, 60]</code>。</td>\n</tr>\n<tr>\n<td>src_frame_rate</td>\n<td>输入帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>dst_frame_rate</td>\n<td>编码器输出帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>max_bit_rate</td>\n<td>最大bitrate，以kbps为单位。</td>\n</tr>\n<tr>\n<td>bit_rate</td>\n<td>平均bitrate，以kbps为单位。</td>\n</tr>\n</tbody>\n</table>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-316-k_venc_fixqp\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#316-k_venc_fixqp\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1.6 k_venc_fixqp</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义H.264/H.265编码通道Fixqp属性结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct {<br>\n k_u32 gop;<br>\n k_u32 src_frame_rate;<br>\n k_u32 dst_frame_rate;<br>\n k_u32 i_qp; k_u32 p_qp;<br>\n} k_venc_fixqp;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gop</td>\n<td>gop值。</td>\n</tr>\n<tr>\n<td>src_frame_rate</td>\n<td>输入帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>dst_frame_rate</td>\n<td>编码器输出帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>i_qp</td>\n<td>I帧所有宏块Qp值。 取值范围： <code>[0, 51]</code>。</td>\n</tr>\n<tr>\n<td>q_qp</td>\n<td>P帧所有宏块Qp值。 取值范围： <code>[0, 51]</code>。</td>\n</tr>\n</tbody>\n</table>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-317-k_venc_mjpeg_fixqp\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#317-k_venc_mjpeg_fixqp\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.1.7 k_venc_mjpeg_fixqp</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义MJPEG编码通道Fixqp属性结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct {<br>\n k_u32 src_frame_rate;<br>\n k_u32 dst_frame_rate;<br>\n k_u32 q_factor;<br>\n} k_venc_mjpeg_fixqp;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>src_frame_rate</td>\n<td>输入帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>dst_frame_rate</td>\n<td>编码器输出帧率，以fps为单位。</td>\n</tr>\n<tr>\n<td>q_factor</td>\n<td>MJPEG编码的Qfactor。 取值范围： <code>[1, 99]</code>。</td>\n</tr>\n</tbody>\n</table>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-32-kd_mapi_venc_deinit\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#32-kd_mapi_venc_deinit\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.2 kd_mapi_venc_deinit</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">编码通道去初始化。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_deinit(k_u32 chn_num)</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无 。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无。</p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-33-kd_mapi_venc_registercallback\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#33-kd_mapi_venc_registercallback\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.3 kd_mapi_venc_registercallback</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">注册编码通道回调函数，用于编码数据的获取。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_registercallback(k_u32 chn_num, <a href=\"#4141-kd_venc_callback_s\">kd_venc_callback_s</a> *pst_venc_cb);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>pst_venc_cb</td>\n<td>编码器回调函数结构体指针。</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无 。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<h4 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-331-kd_venc_callback_s\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#331-kd_venc_callback_s\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.3.1 kd_venc_callback_s</h4>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">编码回调函数结构体。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct<br>\n{<br>\npfn_venc_dataproc pfn_data_cb;\nk_u8 *p_private_data;<br>\n}kd_venc_callback_s;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pfn_data_cb</td>\n<td>回调处理函数。用于获取编码数据</td>\n</tr>\n<tr>\n<td>p_private_data</td>\n<td>私有数据指针。作为参数，在pfn_venc_dataproc中被调用。</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【注意事项】</p>\n<ul dir=\"auto\">\n<li>该结构体被注册后，编码启动后，有编码数据时，pfn_data_cb函数会被调用。用户通过该函数获取编码数据。</li>\n<li>p_private_data为私有数据，用户可选用。</li>\n</ul>\n<h5 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-332-pfn_venc_dataproc\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#332-pfn_venc_dataproc\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.3.2 pfn_venc_dataproc</h5>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">定义编码数据回调函数。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef k_s32 (*pfn_venc_dataproc)(k_u32 chn_num, <a href=\"#4144-k_venc_data_pack_s\">kd_venc_data_s</a> *p_vstream_data, k_u8 *p_private_data);</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>编码通道句柄</td>\n</tr>\n<tr>\n<td>kd_venc_data_s</td>\n<td>数据指针</td>\n</tr>\n<tr>\n<td>p_private_data</td>\n<td>私有数据指针</td>\n</tr>\n</tbody>\n</table>\n<h5 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-333-kd_venc_data_s\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#333-kd_venc_data_s\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.3.3 kd_venc_data_s</h5>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">编码后的数据包类型。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct\n{\n <a href=\"#3122-k_venc_chn_status\">k_venc_chn_status</a> status;\n k_u32 u32_pack_cnt;\n <a href=\"#4144-k_venc_data_pack_s\">k_venc_data_pack_s</a> astPack <code>[</code><a href=\"#4145-kd_venc_max_frame_packcount\">KD_VENC_MAX_FRAME_PACKCOUNT</a><code>]</code>;\n}kd_venc_data_s;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>status</td>\n<td>通道状态</td>\n</tr>\n<tr>\n<td>u32_pack_cnt</td>\n<td>包的数量</td>\n</tr>\n<tr>\n<td>astPack</td>\n<td>数据包</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【注意事项】</p>\n<p dir=\"auto\">无。</p>\n<h5 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-334-k_venc_data_pack_s\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#334-k_venc_data_pack_s\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.3.4 k_venc_data_pack_s</h5>\n<p dir=\"auto\">【说明】</p>\n<p dir=\"auto\">编码后的数据包类型。</p>\n<p dir=\"auto\">【定义】</p>\n<p dir=\"auto\">typedef struct<br>\n{<br>\n k_char * vir_addr;<br>\n k_u64 phys_addr;<br>\n k_u32 len;<br>\n k_u64 pts;<br>\n k_venc_pack_type type;<br>\n}k_venc_data_pack_s;</p>\n<p dir=\"auto\">【成员】</p>\n<table>\n<thead>\n<tr>\n<th>成员名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vir_addr</td>\n<td>数据包的虚拟地址</td>\n</tr>\n<tr>\n<td>phys_addr</td>\n<td>数据包的物理地址</td>\n</tr>\n<tr>\n<td>len</td>\n<td>数据包的长度</td>\n</tr>\n<tr>\n<td>pts</td>\n<td>时间戳</td>\n</tr>\n<tr>\n<td>type</td>\n<td>码流PACK类型</td>\n</tr>\n</tbody>\n</table>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-34-kd_mapi_venc_unregistercallback\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#34-kd_mapi_venc_unregistercallback\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.4 kd_mapi_venc_unregistercallback</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">解注册编码通道回调函数。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_unregistercallback(k_u32 chn_num, <a href=\"#4141-kd_venc_callback_s\">kd_venc_callback_s</a> *pst_venc_cb);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>pst_venc_cb</td>\n<td>编码器回调函数结构体指针。</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无 。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h</p>\n<p dir=\"auto\">库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<p dir=\"auto\">pst_venc_cb回调函数结构体内容与注册时的结构体内容完全一致时才能解注册该回调函数。</p>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无</p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-35-kd_mapi_venc_start\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#35-kd_mapi_venc_start\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.5 kd_mapi_venc_start</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">启动编码通道。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_start(k_s32 chn_num ,k_s32 s32_frame_cnt);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>s32_frame_cnt</td>\n<td>期望编码帧的个数</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无 。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无。</p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-36-kd_mapi_venc_stop\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#36-kd_mapi_venc_stop\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.6 kd_mapi_venc_stop</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">停止编码通道。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_stop(k_s32 chn_num);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无。</p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-37-kd_mapi_venc_bind_vi\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#37-kd_mapi_venc_bind_vi\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.7 kd_mapi_venc_bind_vi</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">编码通道绑定输入源VI</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_bind_vi(k_s32 src_dev, k_s32 src_chn,k_s32 chn_num);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>src_dev</td>\n<td>输入源Device ID</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>src_chn</td>\n<td>输入源Channel ID</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无。</p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-38-kd_mapi_venc_unbind_vi\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#38-kd_mapi_venc_unbind_vi\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.8 kd_mapi_venc_unbind_vi</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">解绑定编码通道的输入源VI。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_unbind_vi(k_s32 src_dev, k_s32 src_chn, k_s32 chn_num);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>src_dev</td>\n<td>输入源Device ID</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>src_chn</td>\n<td>输入源Channel ID</td>\n<td>输入</td>\n</tr>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：[0, VENC_MAX_CHN_NUM)</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无。</p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-39-kd_mapi_venc_request_idr\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#39-kd_mapi_venc_request_idr\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.9 kd_mapi_venc_request_idr</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">请求IDR帧，在调用之后立即产生一个IDR帧。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_request_idr(k_s32 chn_num);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：<code>[0, VENC_MAX_CHN_NUM]</code></td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无。</p>\n<h3 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-310-kd_mapi_venc_enable_idr\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#310-kd_mapi_venc_enable_idr\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>3.10 kd_mapi_venc_enable_idr</h3>\n<p dir=\"auto\">【描述】</p>\n<p dir=\"auto\">使能IDR帧，根据GOP间隔产生IDR帧。</p>\n<p dir=\"auto\">【语法】</p>\n<p dir=\"auto\">k_s32 kd_mapi_venc_enable_idr(k_s32 chn_num, k_bool idr_enable);</p>\n<p dir=\"auto\">【参数】</p>\n<table>\n<thead>\n<tr>\n<th>参数名称</th>\n<th>描述</th>\n<th>输入/输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>chn_num</td>\n<td>VENC 通道号 取值范围：<code>[0, VENC_MAX_CHN_NUM]</code></td>\n<td>输入</td>\n</tr>\n<tr>\n<td>idr_enable</td>\n<td>是否是能IDR帧，0:不使能 1:使能</td>\n<td>输入</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【返回值】</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>成功</td>\n</tr>\n<tr>\n<td>非0</td>\n<td>失败，其值为<a href=\"#5-%E9%94%99%E8%AF%AF%E7%A0%81\">错误码</a></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">【芯片差异】</p>\n<p dir=\"auto\">无。</p>\n<p dir=\"auto\">【需求】</p>\n<p dir=\"auto\">头文件：mapi_venc_api.h、k_venc_comm.h\n库文件：libmapi.a libipcmsg.a libdatafifo.a</p>\n<p dir=\"auto\">【注意】</p>\n<ul dir=\"auto\">\n<li>该接口应在<a href=\"#211-kd_mpi_venc_create_chn\">kd_mpi_venc_create_chn</a>之后，<a href=\"#213-kd_mpi_venc_start_chn\">kd_mpi_venc_start_chn</a>之前调用。</li>\n</ul>\n<p dir=\"auto\">【举例】</p>\n<p dir=\"auto\">无。</p>\n<h2 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-4-错误码\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#4-错误码\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>4. 错误码</h2>\n<p dir=\"auto\">编码 API 错误码</p>\n<table>\n<thead>\n<tr>\n<th>错误代码</th>\n<th>宏定义</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0xa0098001</td>\n<td>K_ERR_VENC_INVALID_DEVID</td>\n<td>设备ID超出合法范围</td>\n</tr>\n<tr>\n<td>0xa0098002</td>\n<td>K_ERR_VENC_INVALID_CHNID</td>\n<td>通道ID超出合法范围</td>\n</tr>\n<tr>\n<td>0xa0098003</td>\n<td>K_ERR_VENC_ILLEGAL_PARAM</td>\n<td>参数超出合法范围</td>\n</tr>\n<tr>\n<td>0xa0098004</td>\n<td>K_ERR_VENC_EXIST</td>\n<td>试图申请或者创建已经存在的设备、通道或者资源</td>\n</tr>\n<tr>\n<td>0xa0098005</td>\n<td>K_ERR_VENC_UNEXIST</td>\n<td>试图使用或者销毁不存在的设备、通道或者资源</td>\n</tr>\n<tr>\n<td>0xa0098006</td>\n<td>K_ERR_VENC_NULL_PTR</td>\n<td>函数参数中有空指针</td>\n</tr>\n<tr>\n<td>0xa0098007</td>\n<td>K_ERR_VENC_NOT_CONFIG</td>\n<td>使用前未配置</td>\n</tr>\n<tr>\n<td>0xa0098008</td>\n<td>K_ERR_VENC_NOT_SUPPORT</td>\n<td>不支持的参数或者功能</td>\n</tr>\n<tr>\n<td>0xa0098009</td>\n<td>K_ERR_VENC_NOT_PERM</td>\n<td>该操作不允许，如试图修改静态配置参数</td>\n</tr>\n<tr>\n<td>0xa009800c</td>\n<td>K_ERR_VENC_NOMEM</td>\n<td>分配内存失败，如系统内存不足</td>\n</tr>\n<tr>\n<td>0xa009800d</td>\n<td>K_ERR_VENC_NOBUF</td>\n<td>分配缓存失败，如申请的数据缓冲区太大</td>\n</tr>\n<tr>\n<td>0xa009800e</td>\n<td>K_ERR_VENC_BUF_EMPTY</td>\n<td>缓冲区中无数据</td>\n</tr>\n<tr>\n<td>0xa009800f</td>\n<td>K_ERR_VENC_BUF_FULL</td>\n<td>缓冲区中数据满</td>\n</tr>\n<tr>\n<td>0xa0098010</td>\n<td>K_ERR_VENC_NOTREADY</td>\n<td>系统没有初始化或没有加载相应模块</td>\n</tr>\n<tr>\n<td>0xa0098011</td>\n<td>K_ERR_VENC_BADADDR</td>\n<td>地址超出合法范围</td>\n</tr>\n<tr>\n<td>0xa0098012</td>\n<td>K_ERR_VENC_BUSY</td>\n<td>VENC系统忙</td>\n</tr>\n</tbody>\n</table>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"                              |\"><pre class=\"notranslate\"><code>                              |\n</code></pre></div>\n<h2 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-5-调试信息\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#5-调试信息\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>5. 调试信息</h2>\n<p dir=\"auto\">多媒体内存管理和和系统绑定调试信息，请参考《K230 系统控制 API参考》。</p>\n<h2 tabindex=\"-1\" dir=\"auto\"><a id=\"user-content-6-sample\" class=\"anchor\" aria-hidden=\"true\" tabindex=\"-1\" href=\"#6-sample\"><svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a>6. sample</h2>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;string.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;getopt.h&gt;\n#include &lt;signal.h&gt;\n#include &quot;mapi_sys_api.h&quot;\n#include &quot;mapi_vvi_api.h&quot;\n#include &quot;mapi_venc_api.h&quot;\n#include &quot;mapi_vicap_api.h&quot;\n#include &quot;k_vicap_comm.h&quot;\n\n#define MAX_CHN_NUM 3\n#define VI_ALIGN_UP(addr, size) (((addr)+((size)-1U))&amp;(~((size)-1U)))\n\nstatic k_u8 g_exit = 0;\nstatic FILE *fp[MAX_CHN_NUM] = {NULL};\nstatic int stream_count[MAX_CHN_NUM] = {0};\nstatic int is_jpeg_type[MAX_CHN_NUM] = {0};\nstatic char jpeg_out_path[128];\n\nstatic void sig_handler(int sig) {\n    g_exit = 1;\n}\n\nk_s32 get_venc_stream(k_u32 chn_num, kd_venc_data_s* p_vstream_data, k_u8 *p_private_data)\n{\n    int cut = p_vstream_data-&gt;status.cur_packs;\n    int i = 0;\n    k_char * pdata  = NULL;\n    \n    if (!is_jpeg_type[chn_num]) {\n        for(i = 0;i &lt; cut;i++) {\n            pdata =  p_vstream_data-&gt;astPack[i].vir_addr;\n            if(stream_count[chn_num] % 90 == 0)\n                printf(&quot;recv count:%d, chn:%d, phys_addr:0x%lx, len:%d, data:[%02x %02x %02x %02x %02x]\\n&quot;,\n                stream_count[chn_num], chn_num, p_vstream_data-&gt;astPack[i].phys_addr, p_vstream_data-&gt;astPack[i].len,pdata[0],pdata[1],pdata[2],pdata[3],pdata[4]);\n\n            if (stream_count[chn_num] &lt;= 1000) {\n                fwrite(pdata, 1, p_vstream_data-&gt;astPack[i].len, fp[chn_num]);\n                fflush(fp[chn_num]);\n            }\n        }\n    } else {\n        if (stream_count[chn_num] &lt;= 10) {\n            char jpg_name[128];\n            snprintf(jpg_name, 128, &quot;%s/chn%d_%d.jpg&quot;, jpeg_out_path, chn_num, stream_count[chn_num]);\n            FILE *fp_jpg = fopen(jpg_name, &quot;wb&quot;);\n            for(i = 0; i &lt; cut; i++) {\n                pdata = p_vstream_data-&gt;astPack[i].vir_addr;\n                printf(&quot;recv count:%d, chn:%d, phys_addr:0x%lx, len:%d, data:[%02x %02x %02x %02x %02x]\\n&quot;,\n                    stream_count[chn_num], chn_num, p_vstream_data-&gt;astPack[i].phys_addr, p_vstream_data-&gt;astPack[i].len,pdata[0],pdata[1],pdata[2],pdata[3],pdata[4]);\n\n                fwrite(pdata, 1, p_vstream_data-&gt;astPack[i].len, fp_jpg);\n                fflush(fp_jpg);\n            }\n            fclose(fp_jpg);\n        }\n    }\n    stream_count[chn_num]++;\n}\n\ntypedef struct {\n    k_vicap_sensor_type sensor_type;\n    k_payload_type type;\n    k_u32 chn_num;\n    char out_path[128];\n} SampleCtx;\n\nstruct option long_options[] = {\n    {&quot;sensor_type&quot;, required_argument, NULL, 's'},\n    {&quot;chn_num&quot;, required_argument, NULL, 'n'},\n    {&quot;type&quot;, required_argument, NULL, 't'},\n    {&quot;out_path&quot;, required_argument, NULL, 'o'},\n    {&quot;help&quot;, required_argument, NULL, 'h'},\n    {NULL, 0, NULL, 0},\n};\n\nstatic k_payload_type get_venc_type(k_u32 vtype_index) {\n    switch (vtype_index) {\n        case 0:\n            return K_PT_H264;\n        case 1:\n            return K_PT_H265;\n        case 2:\n            return K_PT_JPEG;\n        default:\n            printf(&quot;encoder type %d is unsupported, use K_PT_H265 default.\\n&quot;, vtype_index);\n            return K_PT_H265;\n    }\n}\n\nk_u32 parse_option(int argc, char *argv[], SampleCtx *psample_ctx) {\n    if (argc &gt; 1) {\n        int c;\n        int option_index = 0;\n        while ((c = getopt_long(argc, argv, &quot;s:n:t:o:h&quot;, long_options, &amp;option_index)) != -1) {\n            switch (c) {\n                case 's': {\n                    psample_ctx-&gt;sensor_type = (k_vicap_sensor_type)atoi(optarg);\n                    printf(&quot;sensor type: %d.\\n&quot;, psample_ctx-&gt;sensor_type);\n                    break;\n                }\n                case 'n': {\n                    psample_ctx-&gt;chn_num = atoi(optarg);\n                    if (psample_ctx-&gt;chn_num &lt; 1 || psample_ctx-&gt;chn_num &gt; MAX_CHN_NUM) {\n                        printf(&quot;sample not support chn_num &gt; 3 or chn_num &lt; 1, please check by %s -h \\n&quot;, argv[0]);\n                        return -1;\n                    }\n                    printf(&quot;chn_num: %d.\\n&quot;, psample_ctx-&gt;chn_num);\n                    break;\n                }\n                case 't': {\n                    psample_ctx-&gt;type = get_venc_type(atoi(optarg));\n                    printf(&quot;encoder payload type: %d.\\n&quot;, psample_ctx-&gt;type);\n                    break;\n                }\n                case 'o': {\n                    if (access(optarg, F_OK) != 0) {\n                        printf(&quot;output path %s is not exist.\\n&quot;, optarg);\n                        return -1;\n                    }\n                    strcpy(psample_ctx-&gt;out_path, optarg);\n                    printf(&quot;output path: %s.\\n&quot;, psample_ctx-&gt;out_path);\n                    break;\n                }\n                case 'h': {\n                    printf(&quot;Usage: %s -s 0 -n 2 -t 0\\n&quot;, argv[0]);\n                    printf(&quot;          -s or --sensor_type [sensor_index],\\n&quot;);\n                    printf(&quot;                                see vicap doc\\n&quot;);\n                    printf(&quot;          -n or --chn_num [number], 1, 2, 3.\\n&quot;);\n                    printf(&quot;          -t or --type [type_index],\\n&quot;);\n                    printf(&quot;                        0: h264 type\\n&quot;);\n                    printf(&quot;                        1: h265 type\\n&quot;);\n                    printf(&quot;                        2: jpeg type\\n&quot;);\n                    printf(&quot;          -o or --out_path [output_path].\\n&quot;);\n                    printf(&quot;          -h or --help, will print usage.\\n&quot;);\n                    return 1;\n                }\n                default: {\n                    printf(&quot;Invalid option, please check by %s -h\\n&quot;, argv[0]);\n                    return -1;\n                }\n            }\n        }\n    }\n    return K_SUCCESS;\n}\n\nint main(int argc, char *argv[]) {\n\n    signal(SIGINT, sig_handler);\n\n    SampleCtx sample_context = {\n        .sensor_type = IMX335_MIPI_2LANE_RAW12_1920X1080_30FPS_LINEAR,\n        .type = K_PT_H264,\n        .chn_num = 1,\n        .out_path = &quot;/tmp/&quot;\n    };\n\n    k_u32 ret = parse_option(argc, argv, &amp;sample_context);\n    if (ret != K_SUCCESS) {\n        if (ret &gt; 0)\n            return 0;\n\n        printf(&quot;parse_option failed.\\n&quot;);\n        return -1;\n    }\n\n    strcpy(jpeg_out_path, sample_context.out_path);\n\n    printf(&quot;mapi sample_venc...\\n&quot;);\n\n    ret = kd_mapi_sys_init();\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_sys_init failed, %x.\\n&quot;, ret);\n        return -1;\n    }\n\n    // vicap init\n    k_vicap_sensor_info sensor_info;\n    memset(&amp;sensor_info, 0, sizeof(sensor_info));\n    sensor_info.sensor_type = sample_context.sensor_type;\n    ret = kd_mapi_vicap_get_sensor_info(&amp;sensor_info);\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_vicap_get_sensor_info failed, %x.\\n&quot;, ret);\n        goto venc_deinit;\n    }\n\n    k_vicap_dev_set_info dev_attr_info;\n    memset(&amp;dev_attr_info, 0, sizeof(dev_attr_info));\n    if (sample_context.sensor_type &lt;= OV_OV9286_MIPI_1280X720_60FPS_10BIT_LINEAR_IR_SPECKLE || sample_context.sensor_type &gt;= SC_SC035HGS_MIPI_1LANE_RAW10_640X480_120FPS_LINEAR)\n        dev_attr_info.dw_en = K_FALSE;\n    else\n        dev_attr_info.dw_en = K_TRUE;\n\n    k_u32 pic_width[MAX_CHN_NUM] = {1280, 960, 640 };\n    k_u32 pic_height[MAX_CHN_NUM] = {720, 640, 480};\n    k_mapi_media_attr_t media_attr;\n    memset(&amp;media_attr, 0, sizeof(media_attr));\n    media_attr.media_config.vb_config.max_pool_cnt = sample_context.chn_num * 2 + 1;\n    for (int i = 0; i &lt; sample_context.chn_num; i++) {\n        k_u32 pic_size = pic_width[i] * pic_height[i] * 3 / 2;\n        k_u32 stream_size = pic_width[i] * pic_height[i] * 3 / 4;\n        media_attr.media_config.vb_config.comm_pool[i * 2].blk_cnt = 6;\n        media_attr.media_config.vb_config.comm_pool[i * 2].blk_size = ((pic_size + 0xfff) &amp; ~0xfff);\n        media_attr.media_config.vb_config.comm_pool[i * 2].mode = VB_REMAP_MODE_NOCACHE;\n        media_attr.media_config.vb_config.comm_pool[i * 2 + 1].blk_cnt = 30;\n        media_attr.media_config.vb_config.comm_pool[i * 2 + 1].blk_size = ((stream_size + 0xfff) &amp; ~0xfff);\n        media_attr.media_config.vb_config.comm_pool[i * 2 + 1].mode = VB_REMAP_MODE_NOCACHE;\n    }\n\n    if (dev_attr_info.dw_en) {\n        media_attr.media_config.vb_config.comm_pool[sample_context.chn_num * 2].blk_cnt = 6;\n        media_attr.media_config.vb_config.comm_pool[sample_context.chn_num * 2].blk_size = VI_ALIGN_UP(sensor_info.width * sensor_info.height * 3 / 2, 0x400);\n        media_attr.media_config.vb_config.comm_pool[sample_context.chn_num * 2].mode = VB_REMAP_MODE_NOCACHE;\n    }\n\n    memset(&amp;media_attr.media_config.vb_supp.supplement_config, 0, sizeof(media_attr.media_config.vb_supp.supplement_config));\n    media_attr.media_config.vb_supp.supplement_config |= VB_SUPPLEMENT_JPEG_MASK;\n\n    ret = kd_mapi_media_init(&amp;media_attr);\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_media_init failed, %x.\\n&quot;, ret);\n        goto sys_deinit;\n    }\n\n    dev_attr_info.pipe_ctrl.data = 0xFFFFFFFF;\n    dev_attr_info.sensor_type = sample_context.sensor_type;\n    dev_attr_info.vicap_dev = VICAP_DEV_ID_0;\n    ret = kd_mapi_vicap_set_dev_attr(dev_attr_info);\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_vicap_set_dev_attr failed, %x.\\n&quot;, ret);\n        goto sys_deinit;\n    }\n\n    k_venc_chn_attr venc_chn_attr;\n    memset(&amp;venc_chn_attr, 0, sizeof(venc_chn_attr));\n    venc_chn_attr.rc_attr.rc_mode = K_VENC_RC_MODE_CBR;\n    venc_chn_attr.rc_attr.cbr.src_frame_rate = 30;\n    venc_chn_attr.rc_attr.cbr.dst_frame_rate = 30;\n    venc_chn_attr.rc_attr.cbr.bit_rate = 4000;\n    venc_chn_attr.venc_attr.type = sample_context.type;\n    if (sample_context.type == K_PT_H264) {\n        venc_chn_attr.venc_attr.profile = VENC_PROFILE_H264_HIGH;\n    } else if (sample_context.type == K_PT_H265) {\n        venc_chn_attr.venc_attr.profile = VENC_PROFILE_H265_MAIN;\n    } else if (sample_context.type == K_PT_JPEG) {\n        venc_chn_attr.rc_attr.rc_mode = K_VENC_RC_MODE_FIXQP;\n        venc_chn_attr.rc_attr.mjpeg_fixqp.src_frame_rate = 30;\n        venc_chn_attr.rc_attr.mjpeg_fixqp.dst_frame_rate = 30;\n        venc_chn_attr.rc_attr.mjpeg_fixqp.q_factor = 45;\n    }\n\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        char filename[128];\n        if (sample_context.type == K_PT_H264) {\n            snprintf(filename, 128, &quot;%s/stream_chn%d.264&quot;, sample_context.out_path, venc_idx);\n        } else if (sample_context.type == K_PT_H265) {\n            snprintf(filename, 128, &quot;%s/stream_chn%d.265&quot;, sample_context.out_path, venc_idx);\n        } else if (sample_context.type == K_PT_JPEG) {\n            is_jpeg_type[venc_idx] = 1;\n        }\n        if (sample_context.type != K_PT_JPEG) {\n            fp[venc_idx] = fopen(filename, &quot;wb&quot;);\n            if (fp[venc_idx] == NULL) {\n                printf(&quot;stream file %s open failed.\\n&quot;, filename);\n                goto media_deinit;\n            }\n        }\n\n        k_u32 stream_size = pic_width[venc_idx] * pic_height[venc_idx] * 3 / 4;\n        venc_chn_attr.venc_attr.pic_width = pic_width[venc_idx];\n        venc_chn_attr.venc_attr.pic_height = pic_height[venc_idx];\n        venc_chn_attr.venc_attr.stream_buf_cnt = 30;\n        venc_chn_attr.venc_attr.stream_buf_size = ((stream_size + 0xfff) &amp; ~0xfff);\n        ret = kd_mapi_venc_init(venc_idx, &amp;venc_chn_attr);\n        if (ret != K_SUCCESS) {\n            printf(&quot;init venc %d failed, %x.\\n&quot;, venc_idx, ret);\n            for (int create_idx = 0; create_idx &lt; venc_idx; create_idx++) {\n                ret = kd_mapi_venc_deinit(create_idx);\n                if (ret != K_SUCCESS) {\n                    printf(&quot;deinit venc %d failed, %x.\\n&quot;, create_idx, ret);\n                    return -1;\n                }\n            }\n            goto sys_deinit;\n        }\n    }\n\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        int user_data = venc_idx;\n        kd_venc_callback_s venc_cb;\n        venc_cb.pfn_data_cb = get_venc_stream;\n        venc_cb.p_private_data = (k_u8 *)&amp;user_data;\n        kd_mapi_venc_registercallback(venc_idx, &amp;venc_cb);\n    }\n\n    for (int vichn_idx = 0; vichn_idx &lt; sample_context.chn_num; vichn_idx++) {\n        k_vicap_chn_set_info vi_chn_attr_info;\n        memset(&amp;vi_chn_attr_info, 0, sizeof(vi_chn_attr_info));\n\n        vi_chn_attr_info.crop_en = K_FALSE;\n        vi_chn_attr_info.scale_en = K_FALSE;\n        vi_chn_attr_info.chn_en = K_TRUE;\n        vi_chn_attr_info.crop_h_start = 0;\n        vi_chn_attr_info.crop_v_start = 0;\n        vi_chn_attr_info.out_width = pic_width[vichn_idx];\n        vi_chn_attr_info.out_height = pic_height[vichn_idx];\n        vi_chn_attr_info.pixel_format = PIXEL_FORMAT_YUV_SEMIPLANAR_420;\n        vi_chn_attr_info.vicap_dev = VICAP_DEV_ID_0;\n        vi_chn_attr_info.vicap_chn = (k_vicap_chn)vichn_idx;\n        vi_chn_attr_info.alignment = 12;\n        if (!dev_attr_info.dw_en)\n            vi_chn_attr_info.buf_size = VI_ALIGN_UP(pic_width[vichn_idx] * pic_height[vichn_idx] * 3 / 2, 0x400);\n        else\n            vi_chn_attr_info.buf_size = VI_ALIGN_UP(sensor_info.width * sensor_info.height * 3 / 2, 0x400);\n        ret = kd_mapi_vicap_set_chn_attr(vi_chn_attr_info);\n        if (ret != K_SUCCESS) {\n            printf(&quot;vicap chn %d set attr failed, %x.\\n&quot;, vichn_idx, ret);\n            goto venc_deinit;\n        }\n    }\n\n    // chn start\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        ret = kd_mapi_venc_start(venc_idx, -1);\n        if (ret != K_SUCCESS) {\n            printf(&quot;venc chn %d start failed, %x.\\n&quot;, venc_idx, ret);\n            for (int create_idx = 0; create_idx &lt; venc_idx; create_idx++) {\n                ret = kd_mapi_venc_stop(create_idx);\n                if (ret != K_SUCCESS) {\n                    printf(&quot;venc chn %d stop failed, %x.\\n&quot;, create_idx, ret);\n                    return -1;\n                }\n            }\n            goto venc_deinit;\n        }\n    }\n\n    k_s32 src_dev = VICAP_DEV_ID_0;\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        k_s32 src_chn = venc_idx;\n        ret = kd_mapi_venc_bind_vi(src_dev, src_chn, venc_idx);\n        if (ret != K_SUCCESS) {\n            printf(&quot;venc chn %d bind vi failed, %x.\\n&quot;, venc_idx, ret);\n            for (int idx = 0; idx &lt; venc_idx; idx++) {\n                ret = kd_mapi_venc_unbind_vi(src_dev, idx, idx);\n                if (ret != K_SUCCESS) {\n                    printf(&quot;venc idx %d unbind vi failed, %x.\\n&quot;, idx, ret);\n                    return -1;\n                }\n            }\n            goto venc_stop;\n        }\n    }\n\n    ret = kd_mapi_vicap_start(VICAP_DEV_ID_0);\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_vicap_start failed, %x.\\n&quot;, ret);\n        goto vicap_stop;\n    }\n\n    // waiting thread\n    while (!g_exit) {\n        usleep(50000);\n    }\n\n    for (int idx = 0; idx &lt; sample_context.chn_num; idx++) {\n        ret = kd_mapi_venc_unbind_vi(src_dev, idx, idx);\n        if (ret != K_SUCCESS) {\n            printf(&quot;venc chn %d unbind vi failed, %x.\\n&quot;, idx, ret);\n            return -1;\n        }\n    }\n\nvicap_stop:\n    ret = kd_mapi_vicap_stop(VICAP_DEV_ID_0);\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_vicap_stop failed, %x.\\n&quot;, ret);\n        return -1;\n    }\n\nvenc_stop:\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        ret = kd_mapi_venc_stop(venc_idx);\n        if (ret != K_SUCCESS) {\n            printf(&quot;venc chn %d stop failed, %x.\\n&quot;, venc_idx, ret);\n            return -1;\n        }\n    }\n\nvenc_deinit:\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        ret = kd_mapi_venc_deinit(venc_idx);\n        if (ret != K_SUCCESS) {\n            printf(&quot;venc %d deinit failed, %x.\\n&quot;, venc_idx, ret);\n            return -1;\n        }\n    }\n\nmedia_deinit:\n    ret = kd_mapi_media_deinit();\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_media_deinit failed, %x.\\n&quot;, ret);\n        return -1;\n    }\n\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        if (fp[venc_idx]) {\n            fclose(fp[venc_idx]);\n            fp[venc_idx] = NULL;\n        }\n    }\n\nsys_deinit:\n    ret = kd_mapi_sys_deinit();\n    if (ret != K_SUCCESS) {\n        printf(&quot;kd_mapi_sys_deinit failed, %x.\\n&quot;, ret);\n        return -1;\n    }\n\n    printf(&quot;mapi sample_venc end...\\n&quot;);\n    return 0;\n}\"><pre class=\"notranslate\"><code>#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;string.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;getopt.h&gt;\n#include &lt;signal.h&gt;\n#include \"mapi_sys_api.h\"\n#include \"mapi_vvi_api.h\"\n#include \"mapi_venc_api.h\"\n#include \"mapi_vicap_api.h\"\n#include \"k_vicap_comm.h\"\n\n#define MAX_CHN_NUM 3\n#define VI_ALIGN_UP(addr, size) (((addr)+((size)-1U))&amp;(~((size)-1U)))\n\nstatic k_u8 g_exit = 0;\nstatic FILE *fp[MAX_CHN_NUM] = {NULL};\nstatic int stream_count[MAX_CHN_NUM] = {0};\nstatic int is_jpeg_type[MAX_CHN_NUM] = {0};\nstatic char jpeg_out_path[128];\n\nstatic void sig_handler(int sig) {\n    g_exit = 1;\n}\n\nk_s32 get_venc_stream(k_u32 chn_num, kd_venc_data_s* p_vstream_data, k_u8 *p_private_data)\n{\n    int cut = p_vstream_data-&gt;status.cur_packs;\n    int i = 0;\n    k_char * pdata  = NULL;\n    \n    if (!is_jpeg_type[chn_num]) {\n        for(i = 0;i &lt; cut;i++) {\n            pdata =  p_vstream_data-&gt;astPack[i].vir_addr;\n            if(stream_count[chn_num] % 90 == 0)\n                printf(\"recv count:%d, chn:%d, phys_addr:0x%lx, len:%d, data:[%02x %02x %02x %02x %02x]\\n\",\n                stream_count[chn_num], chn_num, p_vstream_data-&gt;astPack[i].phys_addr, p_vstream_data-&gt;astPack[i].len,pdata[0],pdata[1],pdata[2],pdata[3],pdata[4]);\n\n            if (stream_count[chn_num] &lt;= 1000) {\n                fwrite(pdata, 1, p_vstream_data-&gt;astPack[i].len, fp[chn_num]);\n                fflush(fp[chn_num]);\n            }\n        }\n    } else {\n        if (stream_count[chn_num] &lt;= 10) {\n            char jpg_name[128];\n            snprintf(jpg_name, 128, \"%s/chn%d_%d.jpg\", jpeg_out_path, chn_num, stream_count[chn_num]);\n            FILE *fp_jpg = fopen(jpg_name, \"wb\");\n            for(i = 0; i &lt; cut; i++) {\n                pdata = p_vstream_data-&gt;astPack[i].vir_addr;\n                printf(\"recv count:%d, chn:%d, phys_addr:0x%lx, len:%d, data:[%02x %02x %02x %02x %02x]\\n\",\n                    stream_count[chn_num], chn_num, p_vstream_data-&gt;astPack[i].phys_addr, p_vstream_data-&gt;astPack[i].len,pdata[0],pdata[1],pdata[2],pdata[3],pdata[4]);\n\n                fwrite(pdata, 1, p_vstream_data-&gt;astPack[i].len, fp_jpg);\n                fflush(fp_jpg);\n            }\n            fclose(fp_jpg);\n        }\n    }\n    stream_count[chn_num]++;\n}\n\ntypedef struct {\n    k_vicap_sensor_type sensor_type;\n    k_payload_type type;\n    k_u32 chn_num;\n    char out_path[128];\n} SampleCtx;\n\nstruct option long_options[] = {\n    {\"sensor_type\", required_argument, NULL, 's'},\n    {\"chn_num\", required_argument, NULL, 'n'},\n    {\"type\", required_argument, NULL, 't'},\n    {\"out_path\", required_argument, NULL, 'o'},\n    {\"help\", required_argument, NULL, 'h'},\n    {NULL, 0, NULL, 0},\n};\n\nstatic k_payload_type get_venc_type(k_u32 vtype_index) {\n    switch (vtype_index) {\n        case 0:\n            return K_PT_H264;\n        case 1:\n            return K_PT_H265;\n        case 2:\n            return K_PT_JPEG;\n        default:\n            printf(\"encoder type %d is unsupported, use K_PT_H265 default.\\n\", vtype_index);\n            return K_PT_H265;\n    }\n}\n\nk_u32 parse_option(int argc, char *argv[], SampleCtx *psample_ctx) {\n    if (argc &gt; 1) {\n        int c;\n        int option_index = 0;\n        while ((c = getopt_long(argc, argv, \"s:n:t:o:h\", long_options, &amp;option_index)) != -1) {\n            switch (c) {\n                case 's': {\n                    psample_ctx-&gt;sensor_type = (k_vicap_sensor_type)atoi(optarg);\n                    printf(\"sensor type: %d.\\n\", psample_ctx-&gt;sensor_type);\n                    break;\n                }\n                case 'n': {\n                    psample_ctx-&gt;chn_num = atoi(optarg);\n                    if (psample_ctx-&gt;chn_num &lt; 1 || psample_ctx-&gt;chn_num &gt; MAX_CHN_NUM) {\n                        printf(\"sample not support chn_num &gt; 3 or chn_num &lt; 1, please check by %s -h \\n\", argv[0]);\n                        return -1;\n                    }\n                    printf(\"chn_num: %d.\\n\", psample_ctx-&gt;chn_num);\n                    break;\n                }\n                case 't': {\n                    psample_ctx-&gt;type = get_venc_type(atoi(optarg));\n                    printf(\"encoder payload type: %d.\\n\", psample_ctx-&gt;type);\n                    break;\n                }\n                case 'o': {\n                    if (access(optarg, F_OK) != 0) {\n                        printf(\"output path %s is not exist.\\n\", optarg);\n                        return -1;\n                    }\n                    strcpy(psample_ctx-&gt;out_path, optarg);\n                    printf(\"output path: %s.\\n\", psample_ctx-&gt;out_path);\n                    break;\n                }\n                case 'h': {\n                    printf(\"Usage: %s -s 0 -n 2 -t 0\\n\", argv[0]);\n                    printf(\"          -s or --sensor_type [sensor_index],\\n\");\n                    printf(\"                                see vicap doc\\n\");\n                    printf(\"          -n or --chn_num [number], 1, 2, 3.\\n\");\n                    printf(\"          -t or --type [type_index],\\n\");\n                    printf(\"                        0: h264 type\\n\");\n                    printf(\"                        1: h265 type\\n\");\n                    printf(\"                        2: jpeg type\\n\");\n                    printf(\"          -o or --out_path [output_path].\\n\");\n                    printf(\"          -h or --help, will print usage.\\n\");\n                    return 1;\n                }\n                default: {\n                    printf(\"Invalid option, please check by %s -h\\n\", argv[0]);\n                    return -1;\n                }\n            }\n        }\n    }\n    return K_SUCCESS;\n}\n\nint main(int argc, char *argv[]) {\n\n    signal(SIGINT, sig_handler);\n\n    SampleCtx sample_context = {\n        .sensor_type = IMX335_MIPI_2LANE_RAW12_1920X1080_30FPS_LINEAR,\n        .type = K_PT_H264,\n        .chn_num = 1,\n        .out_path = \"/tmp/\"\n    };\n\n    k_u32 ret = parse_option(argc, argv, &amp;sample_context);\n    if (ret != K_SUCCESS) {\n        if (ret &gt; 0)\n            return 0;\n\n        printf(\"parse_option failed.\\n\");\n        return -1;\n    }\n\n    strcpy(jpeg_out_path, sample_context.out_path);\n\n    printf(\"mapi sample_venc...\\n\");\n\n    ret = kd_mapi_sys_init();\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_sys_init failed, %x.\\n\", ret);\n        return -1;\n    }\n\n    // vicap init\n    k_vicap_sensor_info sensor_info;\n    memset(&amp;sensor_info, 0, sizeof(sensor_info));\n    sensor_info.sensor_type = sample_context.sensor_type;\n    ret = kd_mapi_vicap_get_sensor_info(&amp;sensor_info);\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_vicap_get_sensor_info failed, %x.\\n\", ret);\n        goto venc_deinit;\n    }\n\n    k_vicap_dev_set_info dev_attr_info;\n    memset(&amp;dev_attr_info, 0, sizeof(dev_attr_info));\n    if (sample_context.sensor_type &lt;= OV_OV9286_MIPI_1280X720_60FPS_10BIT_LINEAR_IR_SPECKLE || sample_context.sensor_type &gt;= SC_SC035HGS_MIPI_1LANE_RAW10_640X480_120FPS_LINEAR)\n        dev_attr_info.dw_en = K_FALSE;\n    else\n        dev_attr_info.dw_en = K_TRUE;\n\n    k_u32 pic_width[MAX_CHN_NUM] = {1280, 960, 640 };\n    k_u32 pic_height[MAX_CHN_NUM] = {720, 640, 480};\n    k_mapi_media_attr_t media_attr;\n    memset(&amp;media_attr, 0, sizeof(media_attr));\n    media_attr.media_config.vb_config.max_pool_cnt = sample_context.chn_num * 2 + 1;\n    for (int i = 0; i &lt; sample_context.chn_num; i++) {\n        k_u32 pic_size = pic_width[i] * pic_height[i] * 3 / 2;\n        k_u32 stream_size = pic_width[i] * pic_height[i] * 3 / 4;\n        media_attr.media_config.vb_config.comm_pool[i * 2].blk_cnt = 6;\n        media_attr.media_config.vb_config.comm_pool[i * 2].blk_size = ((pic_size + 0xfff) &amp; ~0xfff);\n        media_attr.media_config.vb_config.comm_pool[i * 2].mode = VB_REMAP_MODE_NOCACHE;\n        media_attr.media_config.vb_config.comm_pool[i * 2 + 1].blk_cnt = 30;\n        media_attr.media_config.vb_config.comm_pool[i * 2 + 1].blk_size = ((stream_size + 0xfff) &amp; ~0xfff);\n        media_attr.media_config.vb_config.comm_pool[i * 2 + 1].mode = VB_REMAP_MODE_NOCACHE;\n    }\n\n    if (dev_attr_info.dw_en) {\n        media_attr.media_config.vb_config.comm_pool[sample_context.chn_num * 2].blk_cnt = 6;\n        media_attr.media_config.vb_config.comm_pool[sample_context.chn_num * 2].blk_size = VI_ALIGN_UP(sensor_info.width * sensor_info.height * 3 / 2, 0x400);\n        media_attr.media_config.vb_config.comm_pool[sample_context.chn_num * 2].mode = VB_REMAP_MODE_NOCACHE;\n    }\n\n    memset(&amp;media_attr.media_config.vb_supp.supplement_config, 0, sizeof(media_attr.media_config.vb_supp.supplement_config));\n    media_attr.media_config.vb_supp.supplement_config |= VB_SUPPLEMENT_JPEG_MASK;\n\n    ret = kd_mapi_media_init(&amp;media_attr);\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_media_init failed, %x.\\n\", ret);\n        goto sys_deinit;\n    }\n\n    dev_attr_info.pipe_ctrl.data = 0xFFFFFFFF;\n    dev_attr_info.sensor_type = sample_context.sensor_type;\n    dev_attr_info.vicap_dev = VICAP_DEV_ID_0;\n    ret = kd_mapi_vicap_set_dev_attr(dev_attr_info);\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_vicap_set_dev_attr failed, %x.\\n\", ret);\n        goto sys_deinit;\n    }\n\n    k_venc_chn_attr venc_chn_attr;\n    memset(&amp;venc_chn_attr, 0, sizeof(venc_chn_attr));\n    venc_chn_attr.rc_attr.rc_mode = K_VENC_RC_MODE_CBR;\n    venc_chn_attr.rc_attr.cbr.src_frame_rate = 30;\n    venc_chn_attr.rc_attr.cbr.dst_frame_rate = 30;\n    venc_chn_attr.rc_attr.cbr.bit_rate = 4000;\n    venc_chn_attr.venc_attr.type = sample_context.type;\n    if (sample_context.type == K_PT_H264) {\n        venc_chn_attr.venc_attr.profile = VENC_PROFILE_H264_HIGH;\n    } else if (sample_context.type == K_PT_H265) {\n        venc_chn_attr.venc_attr.profile = VENC_PROFILE_H265_MAIN;\n    } else if (sample_context.type == K_PT_JPEG) {\n        venc_chn_attr.rc_attr.rc_mode = K_VENC_RC_MODE_FIXQP;\n        venc_chn_attr.rc_attr.mjpeg_fixqp.src_frame_rate = 30;\n        venc_chn_attr.rc_attr.mjpeg_fixqp.dst_frame_rate = 30;\n        venc_chn_attr.rc_attr.mjpeg_fixqp.q_factor = 45;\n    }\n\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        char filename[128];\n        if (sample_context.type == K_PT_H264) {\n            snprintf(filename, 128, \"%s/stream_chn%d.264\", sample_context.out_path, venc_idx);\n        } else if (sample_context.type == K_PT_H265) {\n            snprintf(filename, 128, \"%s/stream_chn%d.265\", sample_context.out_path, venc_idx);\n        } else if (sample_context.type == K_PT_JPEG) {\n            is_jpeg_type[venc_idx] = 1;\n        }\n        if (sample_context.type != K_PT_JPEG) {\n            fp[venc_idx] = fopen(filename, \"wb\");\n            if (fp[venc_idx] == NULL) {\n                printf(\"stream file %s open failed.\\n\", filename);\n                goto media_deinit;\n            }\n        }\n\n        k_u32 stream_size = pic_width[venc_idx] * pic_height[venc_idx] * 3 / 4;\n        venc_chn_attr.venc_attr.pic_width = pic_width[venc_idx];\n        venc_chn_attr.venc_attr.pic_height = pic_height[venc_idx];\n        venc_chn_attr.venc_attr.stream_buf_cnt = 30;\n        venc_chn_attr.venc_attr.stream_buf_size = ((stream_size + 0xfff) &amp; ~0xfff);\n        ret = kd_mapi_venc_init(venc_idx, &amp;venc_chn_attr);\n        if (ret != K_SUCCESS) {\n            printf(\"init venc %d failed, %x.\\n\", venc_idx, ret);\n            for (int create_idx = 0; create_idx &lt; venc_idx; create_idx++) {\n                ret = kd_mapi_venc_deinit(create_idx);\n                if (ret != K_SUCCESS) {\n                    printf(\"deinit venc %d failed, %x.\\n\", create_idx, ret);\n                    return -1;\n                }\n            }\n            goto sys_deinit;\n        }\n    }\n\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        int user_data = venc_idx;\n        kd_venc_callback_s venc_cb;\n        venc_cb.pfn_data_cb = get_venc_stream;\n        venc_cb.p_private_data = (k_u8 *)&amp;user_data;\n        kd_mapi_venc_registercallback(venc_idx, &amp;venc_cb);\n    }\n\n    for (int vichn_idx = 0; vichn_idx &lt; sample_context.chn_num; vichn_idx++) {\n        k_vicap_chn_set_info vi_chn_attr_info;\n        memset(&amp;vi_chn_attr_info, 0, sizeof(vi_chn_attr_info));\n\n        vi_chn_attr_info.crop_en = K_FALSE;\n        vi_chn_attr_info.scale_en = K_FALSE;\n        vi_chn_attr_info.chn_en = K_TRUE;\n        vi_chn_attr_info.crop_h_start = 0;\n        vi_chn_attr_info.crop_v_start = 0;\n        vi_chn_attr_info.out_width = pic_width[vichn_idx];\n        vi_chn_attr_info.out_height = pic_height[vichn_idx];\n        vi_chn_attr_info.pixel_format = PIXEL_FORMAT_YUV_SEMIPLANAR_420;\n        vi_chn_attr_info.vicap_dev = VICAP_DEV_ID_0;\n        vi_chn_attr_info.vicap_chn = (k_vicap_chn)vichn_idx;\n        vi_chn_attr_info.alignment = 12;\n        if (!dev_attr_info.dw_en)\n            vi_chn_attr_info.buf_size = VI_ALIGN_UP(pic_width[vichn_idx] * pic_height[vichn_idx] * 3 / 2, 0x400);\n        else\n            vi_chn_attr_info.buf_size = VI_ALIGN_UP(sensor_info.width * sensor_info.height * 3 / 2, 0x400);\n        ret = kd_mapi_vicap_set_chn_attr(vi_chn_attr_info);\n        if (ret != K_SUCCESS) {\n            printf(\"vicap chn %d set attr failed, %x.\\n\", vichn_idx, ret);\n            goto venc_deinit;\n        }\n    }\n\n    // chn start\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        ret = kd_mapi_venc_start(venc_idx, -1);\n        if (ret != K_SUCCESS) {\n            printf(\"venc chn %d start failed, %x.\\n\", venc_idx, ret);\n            for (int create_idx = 0; create_idx &lt; venc_idx; create_idx++) {\n                ret = kd_mapi_venc_stop(create_idx);\n                if (ret != K_SUCCESS) {\n                    printf(\"venc chn %d stop failed, %x.\\n\", create_idx, ret);\n                    return -1;\n                }\n            }\n            goto venc_deinit;\n        }\n    }\n\n    k_s32 src_dev = VICAP_DEV_ID_0;\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        k_s32 src_chn = venc_idx;\n        ret = kd_mapi_venc_bind_vi(src_dev, src_chn, venc_idx);\n        if (ret != K_SUCCESS) {\n            printf(\"venc chn %d bind vi failed, %x.\\n\", venc_idx, ret);\n            for (int idx = 0; idx &lt; venc_idx; idx++) {\n                ret = kd_mapi_venc_unbind_vi(src_dev, idx, idx);\n                if (ret != K_SUCCESS) {\n                    printf(\"venc idx %d unbind vi failed, %x.\\n\", idx, ret);\n                    return -1;\n                }\n            }\n            goto venc_stop;\n        }\n    }\n\n    ret = kd_mapi_vicap_start(VICAP_DEV_ID_0);\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_vicap_start failed, %x.\\n\", ret);\n        goto vicap_stop;\n    }\n\n    // waiting thread\n    while (!g_exit) {\n        usleep(50000);\n    }\n\n    for (int idx = 0; idx &lt; sample_context.chn_num; idx++) {\n        ret = kd_mapi_venc_unbind_vi(src_dev, idx, idx);\n        if (ret != K_SUCCESS) {\n            printf(\"venc chn %d unbind vi failed, %x.\\n\", idx, ret);\n            return -1;\n        }\n    }\n\nvicap_stop:\n    ret = kd_mapi_vicap_stop(VICAP_DEV_ID_0);\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_vicap_stop failed, %x.\\n\", ret);\n        return -1;\n    }\n\nvenc_stop:\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        ret = kd_mapi_venc_stop(venc_idx);\n        if (ret != K_SUCCESS) {\n            printf(\"venc chn %d stop failed, %x.\\n\", venc_idx, ret);\n            return -1;\n        }\n    }\n\nvenc_deinit:\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        ret = kd_mapi_venc_deinit(venc_idx);\n        if (ret != K_SUCCESS) {\n            printf(\"venc %d deinit failed, %x.\\n\", venc_idx, ret);\n            return -1;\n        }\n    }\n\nmedia_deinit:\n    ret = kd_mapi_media_deinit();\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_media_deinit failed, %x.\\n\", ret);\n        return -1;\n    }\n\n    for (int venc_idx = 0; venc_idx &lt; sample_context.chn_num; venc_idx++) {\n        if (fp[venc_idx]) {\n            fclose(fp[venc_idx]);\n            fp[venc_idx] = NULL;\n        }\n    }\n\nsys_deinit:\n    ret = kd_mapi_sys_deinit();\n    if (ret != K_SUCCESS) {\n        printf(\"kd_mapi_sys_deinit failed, %x.\\n\", ret);\n        return -1;\n    }\n\n    printf(\"mapi sample_venc end...\\n\");\n    return 0;\n}\n</code></pre></div>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"riscvedu","repoName":"K230","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timed_out":false,"not_analyzed":false,"symbols":[{"name":"K230 VENC MAPI介绍","kind":"section_1","ident_start":2,"ident_end":22,"extent_start":0,"extent_end":37977,"fully_qualified_name":"K230 VENC MAPI介绍","ident_utf16":{"start":{"line_number":0,"utf16_col":2},"end":{"line_number":0,"utf16_col":18}},"extent_utf16":{"start":{"line_number":0,"utf16_col":0},"end":{"line_number":1186,"utf16_col":0}}},{"name":"1. 概述","kind":"section_2","ident_start":29,"ident_end":38,"extent_start":26,"extent_end":556,"fully_qualified_name":"1. 概述","ident_utf16":{"start":{"line_number":2,"utf16_col":3},"end":{"line_number":2,"utf16_col":8}},"extent_utf16":{"start":{"line_number":2,"utf16_col":0},"end":{"line_number":7,"utf16_col":0}}},{"name":"2. 编码数据流图","kind":"section_2","ident_start":559,"ident_end":580,"extent_start":556,"extent_end":769,"fully_qualified_name":"2. 编码数据流图","ident_utf16":{"start":{"line_number":7,"utf16_col":3},"end":{"line_number":7,"utf16_col":12}},"extent_utf16":{"start":{"line_number":7,"utf16_col":0},"end":{"line_number":15,"utf16_col":0}}},{"name":"3. API接口","kind":"section_2","ident_start":772,"ident_end":784,"extent_start":769,"extent_end":19256,"fully_qualified_name":"3. API接口","ident_utf16":{"start":{"line_number":15,"utf16_col":3},"end":{"line_number":15,"utf16_col":11}},"extent_utf16":{"start":{"line_number":15,"utf16_col":0},"end":{"line_number":728,"utf16_col":0}}},{"name":"3.1 kd_mapi_venc_init","kind":"section_3","ident_start":1628,"ident_end":1649,"extent_start":1624,"extent_end":8320,"fully_qualified_name":"3.1 kd_mapi_venc_init","ident_utf16":{"start":{"line_number":41,"utf16_col":4},"end":{"line_number":41,"utf16_col":25}},"extent_utf16":{"start":{"line_number":41,"utf16_col":0},"end":{"line_number":262,"utf16_col":0}}},{"name":"3.1.1 k_venc_chn_attr","kind":"section_4","ident_start":2644,"ident_end":2665,"extent_start":2639,"extent_end":3061,"fully_qualified_name":"3.1.1 k_venc_chn_attr","ident_utf16":{"start":{"line_number":79,"utf16_col":5},"end":{"line_number":79,"utf16_col":26}},"extent_utf16":{"start":{"line_number":79,"utf16_col":0},"end":{"line_number":99,"utf16_col":0}}},{"name":"3.1.2 k_venc_attr","kind":"section_4","ident_start":3066,"ident_end":3083,"extent_start":3061,"extent_end":3907,"fully_qualified_name":"3.1.2 k_venc_attr","ident_utf16":{"start":{"line_number":99,"utf16_col":5},"end":{"line_number":99,"utf16_col":22}},"extent_utf16":{"start":{"line_number":99,"utf16_col":0},"end":{"line_number":127,"utf16_col":0}}},{"name":"3.1.3 k_venc_rc_attr","kind":"section_4","ident_start":3912,"ident_end":3932,"extent_start":3907,"extent_end":4908,"fully_qualified_name":"3.1.3 k_venc_rc_attr","ident_utf16":{"start":{"line_number":127,"utf16_col":5},"end":{"line_number":127,"utf16_col":25}},"extent_utf16":{"start":{"line_number":127,"utf16_col":0},"end":{"line_number":156,"utf16_col":0}}},{"name":"3.1.4 k_venc_cbr","kind":"section_4","ident_start":4913,"ident_end":4929,"extent_start":4908,"extent_end":5916,"fully_qualified_name":"3.1.4 k_venc_cbr","ident_utf16":{"start":{"line_number":156,"utf16_col":5},"end":{"line_number":156,"utf16_col":21}},"extent_utf16":{"start":{"line_number":156,"utf16_col":0},"end":{"line_number":186,"utf16_col":0}}},{"name":"3.1.5 k_venc_vbr","kind":"section_4","ident_start":5921,"ident_end":5937,"extent_start":5916,"extent_end":6905,"fully_qualified_name":"3.1.5 k_venc_vbr","ident_utf16":{"start":{"line_number":186,"utf16_col":5},"end":{"line_number":186,"utf16_col":21}},"extent_utf16":{"start":{"line_number":186,"utf16_col":0},"end":{"line_number":214,"utf16_col":0}}},{"name":"3.1.6 k_venc_fixqp","kind":"section_4","ident_start":6910,"ident_end":6928,"extent_start":6905,"extent_end":7687,"fully_qualified_name":"3.1.6 k_venc_fixqp","ident_utf16":{"start":{"line_number":214,"utf16_col":5},"end":{"line_number":214,"utf16_col":23}},"extent_utf16":{"start":{"line_number":214,"utf16_col":0},"end":{"line_number":239,"utf16_col":0}}},{"name":"3.1.7 k_venc_mjpeg_fixqp","kind":"section_4","ident_start":7692,"ident_end":7716,"extent_start":7687,"extent_end":8320,"fully_qualified_name":"3.1.7 k_venc_mjpeg_fixqp","ident_utf16":{"start":{"line_number":239,"utf16_col":5},"end":{"line_number":239,"utf16_col":29}},"extent_utf16":{"start":{"line_number":239,"utf16_col":0},"end":{"line_number":262,"utf16_col":0}}},{"name":"3.2 kd_mapi_venc_deinit","kind":"section_3","ident_start":8324,"ident_end":8347,"extent_start":8320,"extent_end":9130,"fully_qualified_name":"3.2 kd_mapi_venc_deinit","ident_utf16":{"start":{"line_number":262,"utf16_col":4},"end":{"line_number":262,"utf16_col":27}},"extent_utf16":{"start":{"line_number":262,"utf16_col":0},"end":{"line_number":303,"utf16_col":0}}},{"name":"3.3 kd_mapi_venc_registercallback","kind":"section_3","ident_start":9134,"ident_end":9167,"extent_start":9130,"extent_end":12491,"fully_qualified_name":"3.3 kd_mapi_venc_registercallback","ident_utf16":{"start":{"line_number":303,"utf16_col":4},"end":{"line_number":303,"utf16_col":37}},"extent_utf16":{"start":{"line_number":303,"utf16_col":0},"end":{"line_number":436,"utf16_col":0}}},{"name":"3.3.1 kd_venc_callback_s","kind":"section_4","ident_start":10111,"ident_end":10135,"extent_start":10106,"extent_end":12491,"fully_qualified_name":"3.3.1 kd_venc_callback_s","ident_utf16":{"start":{"line_number":337,"utf16_col":5},"end":{"line_number":337,"utf16_col":29}},"extent_utf16":{"start":{"line_number":337,"utf16_col":0},"end":{"line_number":436,"utf16_col":0}}},{"name":"3.3.2 pfn_venc_dataproc","kind":"section_5","ident_start":10908,"ident_end":10931,"extent_start":10902,"extent_end":11357,"fully_qualified_name":"3.3.2 pfn_venc_dataproc","ident_utf16":{"start":{"line_number":363,"utf16_col":6},"end":{"line_number":363,"utf16_col":29}},"extent_utf16":{"start":{"line_number":363,"utf16_col":0},"end":{"line_number":381,"utf16_col":0}}},{"name":"3.3.3 kd_venc_data_s","kind":"section_5","ident_start":11363,"ident_end":11383,"extent_start":11357,"extent_end":11925,"fully_qualified_name":"3.3.3 kd_venc_data_s","ident_utf16":{"start":{"line_number":381,"utf16_col":6},"end":{"line_number":381,"utf16_col":26}},"extent_utf16":{"start":{"line_number":381,"utf16_col":0},"end":{"line_number":408,"utf16_col":0}}},{"name":"3.3.4 k_venc_data_pack_s","kind":"section_5","ident_start":11931,"ident_end":11955,"extent_start":11925,"extent_end":12491,"fully_qualified_name":"3.3.4 k_venc_data_pack_s","ident_utf16":{"start":{"line_number":408,"utf16_col":6},"end":{"line_number":408,"utf16_col":30}},"extent_utf16":{"start":{"line_number":408,"utf16_col":0},"end":{"line_number":436,"utf16_col":0}}},{"name":"3.4 kd_mapi_venc_unregistercallback","kind":"section_3","ident_start":12495,"ident_end":12530,"extent_start":12491,"extent_end":13605,"fully_qualified_name":"3.4 kd_mapi_venc_unregistercallback","ident_utf16":{"start":{"line_number":436,"utf16_col":4},"end":{"line_number":436,"utf16_col":39}},"extent_utf16":{"start":{"line_number":436,"utf16_col":0},"end":{"line_number":479,"utf16_col":0}}},{"name":"3.5 kd_mapi_venc_start","kind":"section_3","ident_start":13609,"ident_end":13631,"extent_start":13605,"extent_end":14507,"fully_qualified_name":"3.5 kd_mapi_venc_start","ident_utf16":{"start":{"line_number":479,"utf16_col":4},"end":{"line_number":479,"utf16_col":26}},"extent_utf16":{"start":{"line_number":479,"utf16_col":0},"end":{"line_number":518,"utf16_col":0}}},{"name":"3.6 kd_mapi_venc_stop","kind":"section_3","ident_start":14511,"ident_end":14532,"extent_start":14507,"extent_end":15307,"fully_qualified_name":"3.6 kd_mapi_venc_stop","ident_utf16":{"start":{"line_number":518,"utf16_col":4},"end":{"line_number":518,"utf16_col":25}},"extent_utf16":{"start":{"line_number":518,"utf16_col":0},"end":{"line_number":559,"utf16_col":0}}},{"name":"3.7 kd_mapi_venc_bind_vi","kind":"section_3","ident_start":15311,"ident_end":15335,"extent_start":15307,"extent_end":16304,"fully_qualified_name":"3.7 kd_mapi_venc_bind_vi","ident_utf16":{"start":{"line_number":559,"utf16_col":4},"end":{"line_number":559,"utf16_col":28}},"extent_utf16":{"start":{"line_number":559,"utf16_col":0},"end":{"line_number":602,"utf16_col":0}}},{"name":"3.8 kd_mapi_venc_unbind_vi","kind":"section_3","ident_start":16308,"ident_end":16334,"extent_start":16304,"extent_end":17315,"fully_qualified_name":"3.8 kd_mapi_venc_unbind_vi","ident_utf16":{"start":{"line_number":602,"utf16_col":4},"end":{"line_number":602,"utf16_col":30}},"extent_utf16":{"start":{"line_number":602,"utf16_col":0},"end":{"line_number":645,"utf16_col":0}}},{"name":"3.9 kd_mapi_venc_request_idr","kind":"section_3","ident_start":17319,"ident_end":17347,"extent_start":17315,"extent_end":18169,"fully_qualified_name":"3.9 kd_mapi_venc_request_idr","ident_utf16":{"start":{"line_number":645,"utf16_col":4},"end":{"line_number":645,"utf16_col":32}},"extent_utf16":{"start":{"line_number":645,"utf16_col":0},"end":{"line_number":686,"utf16_col":0}}},{"name":"3.10 kd_mapi_venc_enable_idr","kind":"section_3","ident_start":18173,"ident_end":18201,"extent_start":18169,"extent_end":19256,"fully_qualified_name":"3.10 kd_mapi_venc_enable_idr","ident_utf16":{"start":{"line_number":686,"utf16_col":4},"end":{"line_number":686,"utf16_col":32}},"extent_utf16":{"start":{"line_number":686,"utf16_col":0},"end":{"line_number":728,"utf16_col":0}}},{"name":"4. 错误码","kind":"section_2","ident_start":19259,"ident_end":19271,"extent_start":19256,"extent_end":21148,"fully_qualified_name":"4. 错误码","ident_utf16":{"start":{"line_number":728,"utf16_col":3},"end":{"line_number":728,"utf16_col":9}},"extent_utf16":{"start":{"line_number":728,"utf16_col":0},"end":{"line_number":751,"utf16_col":0}}},{"name":"5. 调试信息","kind":"section_2","ident_start":21151,"ident_end":21166,"extent_start":21148,"extent_end":21273,"fully_qualified_name":"5. 调试信息","ident_utf16":{"start":{"line_number":751,"utf16_col":3},"end":{"line_number":751,"utf16_col":10}},"extent_utf16":{"start":{"line_number":751,"utf16_col":0},"end":{"line_number":755,"utf16_col":0}}},{"name":"6. sample","kind":"section_2","ident_start":21276,"ident_end":21285,"extent_start":21273,"extent_end":37977,"fully_qualified_name":"6. sample","ident_utf16":{"start":{"line_number":755,"utf16_col":3},"end":{"line_number":755,"utf16_col":12}},"extent_utf16":{"start":{"line_number":755,"utf16_col":0},"end":{"line_number":1186,"utf16_col":0}}}]}},"copilotInfo":null,"copilotAccessAllowed":false,"csrf_tokens":{"/riscvedu/K230/branches":{"post":"27esr4JMSZ4Jwqarr14XVTSKnuCY-q68XEu5eOeXm1WGqwcTqngHn2v4iY6nYhtThaOJygR4sWx-ZlNK5C768w"},"/repos/preferences":{"post":"0At52364LA7cPgHPGcOJHER3K_-sc1jLuh0Bs5b9IZq3eaFpc_j0FW0Plgr-_BkamjBAcf9thVoioSPf-o6n3g"}}},"title":"K230/docs/venc_mapi.md at 52c070d6b8463406f0922a7a24b102ef67dc839e · riscvedu/K230"}